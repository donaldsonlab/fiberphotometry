def raw_signal_trace(fpho_dataframe, output_filename, data_row_index=0):
    """Creates a plot of the raw signal traces
    Parameters
    ----------
    fpho_dataframe: pandas dataframe
                    contains parsed fiberphotometry data
    output_filename: string
                    output png name
    data_row_index: optional integer
                    row containing data to plot

    Returns:
    --------
    output_filename: PNG
                     Plot of data
    """
    # renamed for simplicity
    df = fpho_dataframe

    # Get user input for what to plot
    channel_input = input("----------\n"
                          + "What channel(s) would you like to plot?\n"
                          + "\nOptions are f1Red, f2Red, f1Green, f2Green."
                          + "\n\nIf plotting multiple channels,"
                          + " please separate with a space or comma."
                          + "\n----------\n"
                          + "Selection: ")

    # Make a list of user inputs
    if ',' in channel_input:
        channel_list = channel_input.split(',')
    else:
        channel_list = channel_input.split(' ')

    # quick for loop to catch input error -- input not found in column names
    for channel in channel_list:
        col = df.columns.str.contains(pat=str(channel))
        if not any(col):
            print("Could not find entries for channels you'd like to plot"
                  + " in the dataframe column names."
                  + " You entered <" + channel + "> and the options are "
                  + str(list(df.columns)))
            print('Please restart...\n')
            sys.exit(1)

    # Replace user input with actual column name
    for channel in channel_list:

        if 'f1Red' in str(channel):
            channels = ["f1RedRed"]
            time_col = 'fTimeRed'
            l_color = "r"
        if 'f2Red' in str(channel):
            channels = ["f2RedRed"]
            time_col = 'fTimeRed'
            l_color = "r"
        if 'f1Green' in str(channel):
            channels = ["f1GreenGreen", "f1GreenIso"]
            time_col = 'fTimeGreen'
            l_color = "g"
        if 'f2Green' in str(channel):
            channels = ["f2GreenGreen", "f2GreenIso"]
            time_col = 'fTimeGreen'
            l_color = "g"

        fig = plt.figure(figsize=(7*len(channels), 6),
                         facecolor='w',
                         edgecolor='k',
                         dpi=300)

        for i in range(0, len(channels)):

            channel_data = df[channels[i]].values[data_row_index]
            time_data = df[time_col].values[data_row_index]

            # Initialize plot, add data and title
            ax = fig.add_subplot(1, len(channels), 1+i)
            ax.plot(time_data, channel_data, color=l_color)
            ax.set_title(str(channels[i]))

            # Remove top and right borders
            plt.gca().spines['right'].set_color('none')
            plt.gca().spines['top'].set_color('none')

        # outputs raw sig plot as png file
        rawsig_file_name = output_filename + '_RawSignal_' + channel + '.png'
        plt.savefig(rawsig_file_name, bbox_inches='tight')
        plt.close()


def plot_isosbestic_norm(fpho_dataframe, output_filename):
    """Creates a plot normalizing 1 fiber data to the isosbestic
        Parameters
        ----------
        fpho_dataframe: string
                pandas dataframe
        output_filename: string
                name for output file
        Returns:
        --------
        output_filename_f1GreenNorm.png
        & output_filename_f1RedNorm.png: png files
                containing the normalized plot for each fluorophore
    """

    # Open dataframe
    # Check for Name Error and Permission Error exceptions
    try:
        df = fpho_dataframe
    except NameError:
        print('No ' + fpho_dataframe + ' data frame found')
        sys.exit(1)
    except PermissionError:
        print('Unable to access data frame ' + fpho_dataframe)
        sys.exit(1)

    # Initialize lists for the fluorophores and time
    f1GreenIso = []
    f1GreenGreen = []
    f1GreenTime = []

    f1RedIso = []
    f1RedRed = []
                                                   f1RedTime = []

    # Define columns
    greenIso_col = "f1GreenIso"
    greenGreen_col = "f1GreenGreen"
    greenTime_col = "fTimeGreen"
    redIso_col = "f1RedIso"
    redRed_col = "f1RedRed"
    redTime_col = "fTimeRed"

    # Read through each line of the dataframe
    # Append the isosbectic, fluorophore and time data to their
    # respective vectors, depending on color
    f1GreenIso = df[greenIso_col].values[0]
    f1GreenGreen = df[greenGreen_col].values[0]
    f1GreenTime = df[greenTime_col].values[0]
    f1RedIso = df[redIso_col].values[0]
    f1RedRed = df[redRed_col].values[0]
    f1RedTime = df[redTime_col].values[0]

    # Make sure the iso and color vectors have the same number
    # of values. If not, then trim off the last few values
    # from the longer vector
    if len(f1GreenIso) > len(f1GreenGreen):
        n = len(f1GreenIso) - len(f1GreenGreen)
        del f1GreenIso[-n:]
    elif len(f1GreenIso) < len(f1GreenGreen):
        n = len(f1GreenGreen) - len(f1GreenIso)                                                                 
        del f1GreenGreen[-n:]

    if len(f1RedIso) > len(f1RedRed):
        n = len(f1RedIso) - len(f1RedRed)
        del f1RedIso[-n:]
    elif len(f1RedIso) < len(f1RedRed):
        n = len(f1RedRed) - len(f1RedIso)
        del f1RedRed[-n:]

    # Get coefficients for normalized fit
    regGreen = np.polyfit(f1GreenIso, f1GreenGreen, 1)
    aGreen = regGreen[0]
    bGreen = regGreen[1]

    regRed = np.polyfit(f1RedIso, f1RedRed, 1)
    aRed = regRed[0]
    bRed = regRed[1]

    # Use the coefficients to create a control fit
    controlFitGreen = []
    for value in f1GreenIso:
        controlFitGreen.append(aGreen * value + bGreen)

    controlFitRed = []
    for value in f1RedIso:
        controlFitRed.append(aRed * value + bRed)

    # Normalize the fluorophore data using the control fit
    normDataGreen = []
    for i in range(len(f1GreenGreen)):
        normDataGreen.append((f1GreenGreen[i]
                              - controlFitGreen[i]) / controlFitGreen[i])

    normDataRed = []
    for i in range(len(f1RedRed)):
        normDataRed.append((f1RedRed[i] - controlFitRed[i]) / controlFitRed[i])

    # Make sure the normalized data vector and the time
    # vector have the same number of values. If not, then
    # trim off the last few values from the longer vector
    if len(f1GreenTime) > len(normDataGreen):
        n = len(f1GreenTime) - len(normDataGreen)
        del f1GreenTime[-n:]
    elif len(f1GreenTime) < len(normDataGreen):
        n = len(normDataGreen) - len(f1GreenTime)
        del normDataGreen[-n:]

    if len(f1RedTime) > len(normDataRed):
        n = len(f1RedTime) - len(normDataRed)
        del f1RedTime[-n:]
    elif len(f1RedTime) < len(normDataRed):
        n = len(normDataRed) - len(f1RedTime)
        del normDataRed[-n:]

    # Plot the data for green
    plt.plot(f1GreenTime, normDataGreen)
    plt.title('Green Normalized to Isosbestic')

    # Save the plot in a png file
    green_iso_plot_name = output_filename + '_f1GreenNormIso.png'
    figGreen = plt.savefig(green_iso_plot_name)
    plt.close(figGreen)

    # Plot the data for red
    plt.plot(f1RedTime, normDataRed)
    plt.title('Red Normalized to Isosbestic')

    # Save the plot in a png file
    red_iso_plot_name = output_filename + '_f1RedNormIso.png'
    figRed = plt.savefig(red_iso_plot_name)
    plt.close(figRed)


def fit_exp(values, a, b, c, d):
    """Transforms data into an exponential function
        of the form y=A*exp(-B*X)+C*exp(-D*x)

        Parameters
        ----------
        values: list
                data
        a, b, c, d: integers or floats
                estimates for the parameter values of
                A, B, C and D
    """

    values = np.array(values)

    return a * np.exp(b * values) + c * np.exp(d * values)


def plot_fitted_exp(fpho_dataframe, output_filename):
    """Creates a plot normalizing 1 fiber data to an
        exponential of the form y=A*exp(-B*X)+C*exp(-D*x)

        Parameters
        ----------
        fpho_dataframe: string
                pandas dataframe
        output_filename: string
                name for output csv
        Returns:
        --------
        output_filename_f1GreenNormExp.png
        & output_filename_f1RedNormExp.png: png files
                containing the normalized plot for each fluorophore
    """

    # Open dataframe
    # Check for Name Error and Permission Error exceptions
    try:
        df = fpho_dataframe
    except NameError:
        print('No ' + fpho_dataframe + ' data frame found')
        sys.exit(1)
    except PermissionError:
        print('Unable to access data frame ' + fpho_dataframe)
        sys.exit(1)

    # Initialize lists for the fluorophores and time
    f1GreenGreen = []
    f1GreenTime = []

    f1RedRed = []
    f1RedTime = []

    # Define columns
    greenGreen_col = "f1GreenGreen"
    greenTime_col = "fTimeGreen"
    redRed_col = "f1RedRed"
    redTime_col = "fTimeRed"

    # Read through each line of the dataframe
    # Append the fluorophore and time data to their
    # respective vectors, depending on color
    f1GreenGreen = df[greenGreen_col].values[0]
    f1GreenTime = df[greenTime_col].values[0]
    f1RedRed = df[redRed_col].values[0]
    f1RedTime = df[redTime_col].values[0]

    # Make sure the time and color vectors have the same number
    # of values. If not, then trim off the last few values
    # from the longer vector
    if len(f1GreenTime) > len(f1GreenGreen):
        n = len(f1GreenTime) - len(f1GreenGreen)
        del f1GreenTime[-n:]
    elif len(f1GreenTime) < len(f1GreenGreen):
        n = len(f1GreenGreen) - len(f1GreenTime)
        del f1GreenGreen[-n:]

    if len(f1RedTime) > len(f1RedRed):
        n = len(f1RedTime) - len(f1RedRed)
        del f1RedTime[-n:]
    elif len(f1RedTime) < len(f1RedRed):
        n = len(f1RedRed) - len(f1RedTime)
        del f1RedRed[-n:]

    # Initialize the time data to 0 by subracting each value
    # by the first value
    timeG = []
    for i in range(len(f1GreenTime)):
        timeG.append(f1GreenTime[i] - f1GreenTime[0])

    timeR = []
    for i in range(len(f1RedTime)):
        timeR.append(f1RedTime[i] - f1RedTime[0])

    # Get coefficients for normalized fit using first guesses
    # for the coefficients - B and D (the second and fourth
    # inputs for p0) must be negative, while A and C (the
    # first and third inputs for p0) must be positive
    popt, pcov = curve_fit(fit_exp, timeG, f1GreenGreen,
                           p0=(1.0, -0.001, 1.0, -0.001), maxfev=500000)

    AG = popt[0]  # A value
    BG = popt[1]  # B value
    CG = popt[2]  # C value
    DG = popt[3]  # D value

    popt, pcov = curve_fit(fit_exp, timeR, f1RedRed,
                           p0=(1.0, -0.001, 1.0, -0.001), maxfev=500000)

    AR = popt[0]  # A value
    BR = popt[1]  # B value
    CR = popt[2]  # C value
    DR = popt[3]  # D value

    # Generate fit line using calculated coefficients
    fitGreen = fit_exp(timeG, AG, BG, CG, DG)
    fitRed = fit_exp(timeR, AR, BR, CR, DR)

    # Plot the data for green
    plt.plot(timeG, f1GreenGreen)
    plt.plot(timeG, fitGreen)
    plt.xlabel('Time')
    plt.ylabel('Fluorescence')
    plt.title('Green Normalized to Exponential')

    # Save the plot in a png file
    green_exp_plot_name = output_filename + '_f1GreenNormExp.png'
    figGreen = plt.savefig(green_exp_plot_name)
    plt.close(figGreen)

    # Plot the data for red
    plt.plot(timeR, f1RedRed)
    plt.plot(timeR, fitRed)
    plt.xlabel('Time')
    plt.ylabel('Fluorescence')
    plt.title('Red Normalized to Exponential')

    # Save the plot in a png file
    red_exp_plot_name = output_filename + '_f1RedNormExp.png'
    figRed = plt.savefig(red_exp_plot_name)
    plt.close(figRed)
